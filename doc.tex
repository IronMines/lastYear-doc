\documentclass[a4paper, 11pt]{article}
\usepackage[utf8]{inputenc} 
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{graphicx}
\usepackage{hyperref}

\usepackage[french]{babel}

\usepackage{xcolor}
\usepackage{listings}
\input{macros}
 
\begin{document}

\section{Introduction}

Le projet Ironmines a été créé pour répondre offrir une interface de
programmation pour faire évoluer le robot Kobuki. L'objectif est
bien-sur de le faire concourir à la coupe de France de Robotique.

\section{Installation}
\subsection{Pour le développement}
Le programme ironmines peut être installer sur n'importe quel machine
linux compatible avec ROS groovy. On choisira Ubuntu 12.04 pour le
développement. Cette partie expliquera comment installer une version
entière du programme pour le développent. Il faudra alors installer :
\begin{itemize}
\item ROS - Kobuki
\item Arduino - Roserial
\item PhaROS - Ironmines
\end{itemize}

\subsubsection{ROS - Kobuki}

Tout d'abord il faudra télécharger et installer l'utilitaire PhaROS
Tools, disponible à l'url :\\
\url{http://car.mines-douai.fr/wp-content/uploads/2014/01/pharos.deb}
Alors on pourra procéder à l'installation simplifier de phaROS :

\begin{verbatim}
  pharos ros-install
\end{verbatim}
On pourra alors installer le kobuki :
\begin{verbatim}
  sudo apt-get install ros-groovy-kobuki-desktop
\end{verbatim}

\subsubsection{Arduino - Rosserial}

On pourra installer l'IDE pour Arduino pour permettre d'éditer les
sous-procédure utilisé : 
\begin{lstlisting}
  sudo apt-get arduino
  cd ~/sketchbook
  git clone https://github.com/mattonem/ironminesarduino.git
\end{lstlisting}
Cependant ce projet requière les librairies Rosserial :
\begin{lstlisting}
  cd ~/ros/workspace/src/
  git clone https://github.com/ros-drivers/rosserial.git
  cd ~/ros/workspace/
  catkin_make
  cd ~/sketchbook/libraries
  rosrun rosserial_arduino make_libraries.py .
\end{lstlisting}

\subsubsection{PhaROS - Ironmines}
Il est temps de passer a l'installation de phaROS et du projet
Ironmines. Toute la procédure est très simplifier avec l'outil PhaROS
Tools bien-sur.

\begin{lstlisting}
  pharos register-repository --url="http://smalltalkhub.com/mc/maxmattone/ironmines/main" --package=IronMinesDirectory
  pharos install IronMines
\end{lstlisting}

\subsection{Raspberry}
À partir d'une distribution Raspbian vierge il faudra installer les
dépendances suivantes :

\subsubsection{ROS - Kobuki}
Tout d'abord il faut installer ROS sur le Raspberry : 
\begin{lstlisting}
  sudo sh -c 'echo "deb http://64.91.227.57/repos/rospbian wheezy main" > /etc/apt/sources.list.d/rospbian.list'
  wget http://64.91.227.57/repos/rospbian.key -O - | sudo apt-key add -

  sudo apt-get update

  sudo apt-get install ros-groovy-ros-comm
  pip install --upgrade rosdistro
  sudo rosdep init
  rosdep update

  echo "source /opt/ros/groovy/setup.bash" >> ~/.bashrc
  echo "export ROS_HOSTNAME=localhost" >> ~/.bashrc
  source ~/.bashrc

   mkdir -p ~/ros/workspace/src
   cd ~/ros/workspace/src
   catkin_init_workspace
   cd ~/ros/workspace/
   catkin_make
   echo "source ~/ros/workspace/devel/setup.bash" >> ~/.bashrc
\end{lstlisting}
Puis installer les noeuds pour communiquer avec le Kobuki : 
\begin{lstlisting}
  sudo apt-get install ros-groovy-diagnostics
  sudo apt-get install ros-groovy-kobuki-node 
  sudo apt-get install ros-groovy-kobuki-msgs
  sudo apt-get install ros-groovy-kobuki-ftdi
  rosrun kobuki_ftdi create_udev_rules
\end{lstlisting}
On pourra alors tester l'installation en exécutant dans un terminal :
\begin{verbatim}
  roscore
\end{verbatim}
Et dans un autre terminal : 
\begin{verbatim}
  roslaunch kobuki_node minimal.launch
\end{verbatim}
Si tout ce lance correctement, on peut passer à la suite.
\subsubsection{Rosserial}
  
\section{Architecture}

D'un façon générale, Pharo fait office d'intelligence. ROS ne fait que
transmettre les message provenant de l'Arduino et du Kobuki au travers
des noeuds Rosserial et Kobuki\_node.
\begin{center}
  \includegraphics[width=\linewidth]{./architecture.jpg}
  \caption{Architecture générale}
  \label{archi_generale}
\end{center}
\subsection{Arduino}
Le code pour l'arduino se trouve a l'Url
:\\ \url{https://github.com/mattonem/ironminesarduino.git}.

Basiquement, on utilise la librairie fournie par Rosserial pour
pouvoir publier différents topiques sur le port série ainsi que souscrire
a d'autre. On publie les données relatives au contacteur de démarrage
et au capteurs ultrasons. On souscrit aux différents topiques concernant
les actions a effectuer (activer le canon, bouger le bras
retractable).

\subsubsection{Subscribed Topics}

\begin{itemize}
\item \texttt{/canonTrigger (std\_msgs/Bool)}\\ 
  Si msg.data == true :
  déclenche l'électrovanne pour faire tirer le canon.
\end{itemize}

\subsubsection{Published Topics}

\begin{itemize}
\item \texttt{/sonar/<i> (std\_msgs/UInt16)}\\
  Donne la distance au mur en face du sonar \texttt{i}.\\
  Aujourd'hui, \texttt{i} est compris entre 0 et 4
\item \texttt{/startTrigger (std\_msgs/Bool)}\\ 
  Donne les fronts montant et descendant pour le cordon de démarrage.
\end{itemize}

\subsection{PhaROS - Ironmines}

\begin{center}
  \includegraphics[width=\linewidth]{./UMLClass.jpg}
  \caption{Diagramme de classe}
  \label{dia_class}
\end{center}

Le point d'entrée dans le programme est \texttt{IronMinesPackage} et
sa methode \texttt{scriptKobuki}. C'est cette méthode qui va lancer
l'instantiation de l'ensemble des entités necessaires pour le
programme. Va suivre l'instantiation du \texttt{Controller} et son
assiotiation avec les nodelets utilisées (ici on utilise uniquement
\texttt{PhaROSTransformationNodelet} et
\texttt{KobukiNodelet}). \texttt{KobukiNodelet} s'occupe alors de la
creation d'un objet \texttt{Kobuki}, qui est une représentation
logique du robot.

On peut alors affecter au Kobuki des états. Ceux-ci représentent les
actions qu'on lui demandera de faire (ex: \texttt{EtatGoTo}). Un état
hérite de la classe \texttt{Etat}, et peut définir dans la méthode
\texttt{action} la (les) action(s) actions à effectuer. À la fin de
l'action, si l'état doit finir et mener sur un autre état (ce n'est
pas le cas de tous), on pourra alors appeler la methode
\texttt{onFinish}. 

Il existe differentes façon de sortir d'un etat. La premiere est
déclenché lorsque l'état est terminé (\texttt{onFinish}). Les autres
peuvent être personnalisées : \texttt{onObstacle},
\texttt{onBumperEvent}. Chacune de ces portes de sorties sont
parametrées à l'intantiation par la factory. Exemple :

\begin{code}
  newEtat := EtatFactory createGoTo: (0 @ 1) onObstable: unEtatdEvitement next: etatSuivant.
  kobuki changeEtat: newEtat.
  "NB : je ne présente pas ici une interface finalisee, ces methodes sont suseptibles de changer"
\end{code}

Ici on crée un nouvel état qui demandera de kobuki de se rendre en
\texttt{(0,1)}, puis de passer à l'état \texttt{etatSuivant}, mais en
cas d'obstacle on passera a l'état \texttt{unEtatdEvitement}.  Comme
on peut le voir dans le graphique d'objet suivant (représentant le
kobuki au depart d'un script pour tirer sur le mammouth) les états
peuvent former des graphs complexes.
\begin{center}
  \includegraphics[width=\linewidth]{./UMLObjectEtat.jpg}
  \caption{Diagramme d'objets}
  \label{dia_obj}
\end{center}

\end{document}
